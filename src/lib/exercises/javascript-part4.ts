import { addExercises } from ".";
import type { Exercise } from "@/app/exercises/[module]/exercise-client";

// @ts-nocheck ‚Äî Auto-converted from exercises-js-part4.js
const exercises: Exercise[] = [
    // === PROJET MARIO : IA ENNEMIS (76-80) ===
    {
      id: "js_s1_e76",
      title: "üéÆ IA - Suivre le joueur",
      description: "Projet Mario #26 ‚Äî L'ennemi suit le joueur.",
      instruction: "Cr√©ez <code>chasePlayer(enemy, player, speed)</code> : d√©place l'ennemi vers le joueur. Si player.x > enemy.x, enemy.x += speed, sinon -= speed. Ennemi √† x=200, joueur √† x=400, speed=3. Faites 5 appels. Affichez enemy.x.",
      code_template: "function chasePlayer(enemy, player, speed) {\n  // D√©placez l'ennemi vers le joueur\n}\n\nlet enemy = { x: 200 };\nlet player = { x: 400 };\nfor (let i = 0; i < 5; i++) chasePlayer(enemy, player, 3);\nconsole.log(enemy.x);\n",
      solution: "function chasePlayer(enemy, player, speed) {\n  if (player.x > enemy.x) enemy.x += speed;\n  else if (player.x < enemy.x) enemy.x -= speed;\n}\nlet enemy = { x: 200 };\nlet player = { x: 400 };\nfor (let i = 0; i < 5; i++) chasePlayer(enemy, player, 3);\nconsole.log(enemy.x);",
      tests: [{ type: "output", expected: "215" }],
      hint: "200 + (5 √ó 3) = 215.",
      help_steps: ["1. Si player.x > enemy.x ‚Üí enemy.x += speed", "2. 200 + 15 = 215"],
    },
    {
      id: "js_s1_e77",
      title: "üéÆ IA - Saut intelligent",
      description: "Projet Mario #27 ‚Äî L'ennemi saute par-dessus les obstacles.",
      instruction: "Cr√©ez <code>smartJump(enemy, obstacles)</code> : v√©rifie si un obstacle est devant l'ennemi (dans les 50px). Si oui et onGround, saute (velocityY = -8). Testez avec un obstacle √† x=230, ennemi √† x=200. Affichez <strong>\"Jumped: true\"</strong>.",
      code_template: "function smartJump(enemy, obstacles) {\n  // V√©rifiez si un obstacle est proche devant\n}\n\nlet enemy = { x: 200, y: 300, velocityY: 0, onGround: true, direction: 1 };\nlet obstacles = [{ x: 230, y: 300, width: 30, height: 30 }];\nsmartJump(enemy, obstacles);\nconsole.log(`Jumped: ${enemy.velocityY === -8}`);\n",
      solution: "function smartJump(enemy, obstacles) {\n  if (!enemy.onGround) return;\n  for (let obs of obstacles) {\n    let dist = (obs.x - enemy.x) * enemy.direction;\n    if (dist > 0 && dist < 50) {\n      enemy.velocityY = -8;\n      enemy.onGround = false;\n      return;\n    }\n  }\n}\nlet enemy = { x: 200, y: 300, velocityY: 0, onGround: true, direction: 1 };\nlet obstacles = [{ x: 230, y: 300, width: 30, height: 30 }];\nsmartJump(enemy, obstacles);\nconsole.log(`Jumped: ${enemy.velocityY === -8}`);",
      tests: [{ type: "output", expected: "Jumped: true" }],
      hint: "Distance = (obs.x - enemy.x) √ó direction. Si > 0 et < 50, sauter.",
      help_steps: ["1. Calculez la distance devant l'ennemi", "2. Si < 50px, d√©clenchez le saut"],
    },
    {
      id: "js_s1_e78",
      title: "üéÆ Projectiles",
      description: "Projet Mario #28 ‚Äî Syst√®me de tir (boules de feu).",
      instruction: "Cr√©ez <code>ProjectileSystem</code> avec <code>projectiles</code> (tableau). <code>shoot(x, y, dirX, speed)</code> cr√©e un projectile. <code>update()</code> d√©place tous les projectiles. <code>cleanup(maxX)</code> supprime ceux hors √©cran. Tirez depuis (100,200) vers la droite (speed 8), 3 updates, affichez la position x du projectile.",
      code_template: "// Classe ProjectileSystem\n\n// Testez\n",
      solution: "class ProjectileSystem {\n  constructor() {\n    this.projectiles = [];\n  }\n  shoot(x, y, dirX, speed) {\n    this.projectiles.push({ x, y, vx: dirX * speed, width: 8, height: 8 });\n  }\n  update() {\n    this.projectiles.forEach(p => p.x += p.vx);\n  }\n  cleanup(maxX) {\n    this.projectiles = this.projectiles.filter(p => p.x > 0 && p.x < maxX);\n  }\n}\nlet ps = new ProjectileSystem();\nps.shoot(100, 200, 1, 8);\nps.update();\nps.update();\nps.update();\nconsole.log(ps.projectiles[0].x);",
      tests: [{ type: "output", expected: "124" }],
      hint: "100 + (3 √ó 8) = 124.",
      help_steps: ["1. shoot cr√©e {x, y, vx: dirX * speed}", "2. update: x += vx ‚Üí 100+8+8+8 = 124"],
    },
    {
      id: "js_s1_e79",
      title: "üéÆ D√©g√¢ts et knockback",
      description: "Projet Mario #29 ‚Äî Syst√®me de d√©g√¢ts avec recul.",
      instruction: "Cr√©ez <code>applyDamage(target, damage, knockbackX)</code> : r√©duit target.hp, applique knockbackX √† target.x, met target.invulnerable √† true. Cr√©ez un joueur (hp:100, x:200), appliquez 25 d√©g√¢ts avec knockback -20. Affichez <strong>\"HP:75 X:180\"</strong>.",
      code_template: "function applyDamage(target, damage, knockbackX) {\n  // Appliquez d√©g√¢ts et recul\n}\n\nlet player = { hp: 100, x: 200, invulnerable: false };\napplyDamage(player, 25, -20);\nconsole.log(`HP:${player.hp} X:${player.x}`);\n",
      solution: "function applyDamage(target, damage, knockbackX) {\n  if (target.invulnerable) return;\n  target.hp -= damage;\n  target.x += knockbackX;\n  target.invulnerable = true;\n}\nlet player = { hp: 100, x: 200, invulnerable: false };\napplyDamage(player, 25, -20);\nconsole.log(`HP:${player.hp} X:${player.x}`);",
      tests: [{ type: "output", expected: "HP:75 X:180" }],
      hint: "hp -= damage, x += knockbackX (n√©gatif = recul √† gauche).",
      help_steps: ["1. 100-25=75, 200+(-20)=180"],
    },
    {
      id: "js_s1_e80",
      title: "üéÆ Spawner d'ennemis",
      description: "Projet Mario #30 ‚Äî G√©n√©rateur d'ennemis par vagues.",
      instruction: "Cr√©ez <code>EnemySpawner</code> avec <code>wave: 1, enemies: []</code>. <code>spawnWave()</code> cr√©e <code>wave √ó 2</code> ennemis avec hp = <code>20 + wave √ó 10</code>. Apr√®s spawn, incr√©mente wave. Spawner 2 vagues, affichez le nombre total d'ennemis.",
      code_template: "// Classe EnemySpawner\n\n// Spawner 2 vagues, affichez le total\n",
      solution: "class EnemySpawner {\n  constructor() {\n    this.wave = 1;\n    this.enemies = [];\n  }\n  spawnWave() {\n    let count = this.wave * 2;\n    let hp = 20 + this.wave * 10;\n    for (let i = 0; i < count; i++) {\n      this.enemies.push({ hp: hp, x: Math.random() * 700, y: 300 });\n    }\n    this.wave++;\n  }\n}\nlet spawner = new EnemySpawner();\nspawner.spawnWave();\nspawner.spawnWave();\nconsole.log(spawner.enemies.length);",
      tests: [{ type: "output", expected: "6" }],
      hint: "Vague 1: 2 ennemis. Vague 2: 4 ennemis. Total: 6.",
      help_steps: ["1. wave 1 ‚Üí 1√ó2 = 2 ennemis", "2. wave 2 ‚Üí 2√ó2 = 4 ennemis", "3. Total: 6"],
    },

    // === PROJET MARIO : BOSS & NIVEAUX (81-85) ===
    {
      id: "js_s1_e81",
      title: "üéÆ Boss Fight",
      description: "Projet Mario #31 ‚Äî Cr√©ez un boss avec des phases.",
      instruction: "Cr√©ez <code>Boss</code> avec <code>hp: 300, maxHp: 300, phase: 1</code>. <code>takeDamage(dmg)</code> r√©duit hp. Quand hp < 200 ‚Üí phase 2, hp < 100 ‚Üí phase 3. <code>getPhase()</code> retourne la phase. Infligez 150 d√©g√¢ts, affichez la phase.",
      code_template: "// Classe Boss\n\n// Infligez 150 d√©g√¢ts, affichez la phase\n",
      solution: "class Boss {\n  constructor() {\n    this.hp = 300;\n    this.maxHp = 300;\n    this.phase = 1;\n  }\n  takeDamage(dmg) {\n    this.hp -= dmg;\n    if (this.hp < 100) this.phase = 3;\n    else if (this.hp < 200) this.phase = 2;\n  }\n  getPhase() { return this.phase; }\n}\nlet boss = new Boss();\nboss.takeDamage(150);\nconsole.log(boss.getPhase());",
      tests: [{ type: "output", expected: "2" }],
      hint: "300 - 150 = 150. 150 < 200 ‚Üí phase 2.",
      help_steps: ["1. hp = 300 - 150 = 150", "2. 150 < 200 ‚Üí phase 2"],
    },
    {
      id: "js_s1_e82",
      title: "üéÆ Attaques du Boss",
      description: "Projet Mario #32 ‚Äî Patterns d'attaque du boss.",
      instruction: "Cr√©ez <code>BossAttack</code> avec <code>patterns</code> (tableau de noms) et <code>currentPattern: 0</code>. <code>nextAttack()</code> retourne le pattern actuel et passe au suivant (boucle). Cr√©ez 3 patterns [\"charge\", \"fireball\", \"stomp\"], appelez nextAttack 4 fois. Affichez le dernier r√©sultat.",
      code_template: "// Classe BossAttack\n\n// Testez 4 appels\n",
      solution: 'class BossAttack {\n  constructor(patterns) {\n    this.patterns = patterns;\n    this.currentPattern = 0;\n  }\n  nextAttack() {\n    let attack = this.patterns[this.currentPattern];\n    this.currentPattern = (this.currentPattern + 1) % this.patterns.length;\n    return attack;\n  }\n}\nlet ba = new BossAttack(["charge", "fireball", "stomp"]);\nlet last;\nfor (let i = 0; i < 4; i++) last = ba.nextAttack();\nconsole.log(last);',
      tests: [{ type: "output", expected: "charge" }],
      hint: "4 appels sur 3 patterns : charge, fireball, stomp, charge. Dernier = charge.",
      help_steps: ["1. Index boucle: 0,1,2,0 ‚Üí 4√®me appel retourne patterns[0] = charge"],
    },
    {
      id: "js_s1_e83",
      title: "üéÆ Syst√®me de niveaux",
      description: "Projet Mario #33 ‚Äî Gestion des niveaux du jeu.",
      instruction: "Cr√©ez <code>LevelManager</code> avec <code>levels</code> (tableau), <code>currentLevel: 0</code>. <code>getCurrentLevel()</code>, <code>nextLevel()</code> (retourne false si dernier), <code>isLastLevel()</code>. Cr√©ez 3 niveaux, avancez 2 fois. Affichez le nom du niveau actuel.",
      code_template: "// Classe LevelManager\n\n// 3 niveaux, avancez 2 fois\n",
      solution: 'class LevelManager {\n  constructor(levels) {\n    this.levels = levels;\n    this.currentLevel = 0;\n  }\n  getCurrentLevel() { return this.levels[this.currentLevel]; }\n  nextLevel() {\n    if (this.currentLevel >= this.levels.length - 1) return false;\n    this.currentLevel++;\n    return true;\n  }\n  isLastLevel() { return this.currentLevel >= this.levels.length - 1; }\n}\nlet lm = new LevelManager([\n  { name: "Plaine", platforms: 5 },\n  { name: "Grotte", platforms: 8 },\n  { name: "Ch√¢teau", platforms: 12 }\n]);\nlm.nextLevel();\nlm.nextLevel();\nconsole.log(lm.getCurrentLevel().name);',
      tests: [{ type: "output", expected: "Ch√¢teau" }],
      hint: "2 nextLevel depuis l'index 0 ‚Üí index 2 ‚Üí Ch√¢teau.",
      help_steps: ["1. nextLevel incr√©mente currentLevel", "2. 0 ‚Üí 1 ‚Üí 2 = Ch√¢teau"],
    },
    {
      id: "js_s1_e84",
      title: "üéÆ Objets destructibles",
      description: "Projet Mario #34 ‚Äî Briques cassables comme dans Mario.",
      instruction: "Cr√©ez <code>Brick</code> avec <code>x, y, hp: 2, broken: false, items</code> (tableau). <code>hit()</code> r√©duit hp, si hp <= 0 met broken √† true et retourne items. Sinon retourne []. Cr√©ez une brique avec [\"coin\", \"mushroom\"], frappez 2 fois. Affichez les items l√¢ch√©s.",
      code_template: "// Classe Brick\n\n// Testez\n",
      solution: 'class Brick {\n  constructor(x, y, items = []) {\n    this.x = x;\n    this.y = y;\n    this.hp = 2;\n    this.broken = false;\n    this.items = items;\n  }\n  hit() {\n    if (this.broken) return [];\n    this.hp--;\n    if (this.hp <= 0) {\n      this.broken = true;\n      return this.items;\n    }\n    return [];\n  }\n}\nlet brick = new Brick(100, 200, ["coin", "mushroom"]);\nbrick.hit();\nlet loot = brick.hit();\nconsole.log(loot.join(", "));',
      tests: [{ type: "output", expected: "coin, mushroom" }],
      hint: "2 coups pour casser. Au 2√®me coup, hp = 0 ‚Üí retourne les items.",
      help_steps: ["1. hit() d√©cr√©mente hp", "2. Quand hp <= 0: broken = true, retourne items"],
    },
    {
      id: "js_s1_e85",
      title: "üéÆ Plateformes mobiles",
      description: "Projet Mario #35 ‚Äî Plateformes qui bougent.",
      instruction: "Cr√©ez <code>MovingPlatform</code> qui √©tend un concept de plateforme avec <code>startX, endX, speed, direction: 1</code>. <code>update()</code> d√©place et inverse aux limites. Cr√©ez une plateforme (startX:100, endX:300, speed:5). Faites 10 updates. Affichez x.",
      code_template: "// Classe MovingPlatform\n\n// 10 updates, affichez x\n",
      solution: "class MovingPlatform {\n  constructor(startX, y, width, height, endX, speed) {\n    this.x = startX;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.startX = startX;\n    this.endX = endX;\n    this.speed = speed;\n    this.direction = 1;\n  }\n  update() {\n    this.x += this.speed * this.direction;\n    if (this.x >= this.endX || this.x <= this.startX) {\n      this.direction *= -1;\n    }\n  }\n}\nlet mp = new MovingPlatform(100, 200, 80, 20, 300, 5);\nfor (let i = 0; i < 10; i++) mp.update();\nconsole.log(mp.x);",
      tests: [{ type: "output", expected: "150" }],
      hint: "10 √ó 5 = 50 de d√©placement. Mais inverse √† 300. Calculez la position finale.",
      help_steps: ["1. 100‚Üí105‚Üí...‚Üí300 (40 steps) mais on n'a que 10", "2. 100 + 50 = 150"],
    },

    // === PROJET MARIO : ASSEMBLAGE (86-90) ===
    {
      id: "js_s1_e86",
      title: "üéÆ HUD - Affichage t√™te haute",
      description: "Projet Mario #36 ‚Äî Cr√©ez le HUD du jeu.",
      instruction: "Cr√©ez <code>HUD</code> qui prend un objet <code>gameData</code>. <code>render()</code> retourne une string format√©e. Testez avec score:2500, vies:3, level:2, coins:15. Affichez le rendu.",
      code_template: "// Classe HUD\n\n// Testez\n",
      solution: 'class HUD {\n  constructor(gameData) {\n    this.data = gameData;\n  }\n  render() {\n    return `SCORE:${this.data.score} VIES:${this.data.vies} LEVEL:${this.data.level} COINS:${this.data.coins}`;\n  }\n}\nlet hud = new HUD({ score: 2500, vies: 3, level: 2, coins: 15 });\nconsole.log(hud.render());',
      tests: [{ type: "output", expected: "SCORE:2500 VIES:3 LEVEL:2 COINS:15" }],
      hint: "render() retourne un template literal avec les donn√©es du jeu.",
      help_steps: ["1. Utilisez un template literal pour formater l'affichage"],
    },
    {
      id: "js_s1_e87",
      title: "üéÆ Event System",
      description: "Projet Mario #37 ‚Äî Syst√®me d'√©v√©nements.",
      instruction: "Cr√©ez <code>EventSystem</code> avec <code>listeners</code> (objet). <code>on(event, callback)</code> enregistre un listener. <code>emit(event, data)</code> appelle tous les listeners. Enregistrez \"coin_collected\" qui affiche les points. √âmettez avec {points: 50}.",
      code_template: "// Classe EventSystem\n\n// Testez\n",
      solution: 'class EventSystem {\n  constructor() {\n    this.listeners = {};\n  }\n  on(event, callback) {\n    if (!this.listeners[event]) this.listeners[event] = [];\n    this.listeners[event].push(callback);\n  }\n  emit(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach(cb => cb(data));\n    }\n  }\n}\nlet events = new EventSystem();\nevents.on("coin_collected", (data) => {\n  console.log("+" + data.points + " points");\n});\nevents.emit("coin_collected", { points: 50 });',
      tests: [{ type: "output", expected: "+50 points" }],
      hint: "on() stocke les callbacks, emit() les appelle.",
      help_steps: ["1. listeners = { event: [callback1, callback2] }", "2. emit appelle chaque callback avec data"],
    },
    {
      id: "js_s1_e88",
      title: "üéÆ Dialogue System",
      description: "Projet Mario #38 ‚Äî Dialogues de PNJ.",
      instruction: "Cr√©ez <code>DialogueSystem</code> avec <code>dialogues</code> (tableau de strings) et <code>index: 0</code>. <code>next()</code> retourne le dialogue actuel et avance. <code>isFinished()</code> v√©rifie si tous lus. Cr√©ez 3 dialogues, lisez 2. Affichez le 2√®me.",
      code_template: "// Classe DialogueSystem\n\n// Testez\n",
      solution: 'class DialogueSystem {\n  constructor(dialogues) {\n    this.dialogues = dialogues;\n    this.index = 0;\n  }\n  next() {\n    if (this.index >= this.dialogues.length) return null;\n    let text = this.dialogues[this.index];\n    this.index++;\n    return text;\n  }\n  isFinished() {\n    return this.index >= this.dialogues.length;\n  }\n}\nlet ds = new DialogueSystem(["Bienvenue !", "Le ch√¢teau est au nord.", "Bonne chance !"]);\nds.next();\nlet msg = ds.next();\nconsole.log(msg);',
      tests: [{ type: "output", expected: "Le ch√¢teau est au nord." }],
      hint: "next() retourne dialogues[index] puis incr√©mente.",
      help_steps: ["1. 1er next ‚Üí index 0 ‚Üí 'Bienvenue !'", "2. 2√®me next ‚Üí index 1 ‚Üí 'Le ch√¢teau est au nord.'"],
    },
    {
      id: "js_s1_e89",
      title: "üéÆ Achievements",
      description: "Projet Mario #39 ‚Äî Syst√®me de succ√®s.",
      instruction: "Cr√©ez <code>AchievementSystem</code> avec des achievements (id, name, condition). <code>check(gameData)</code> v√©rifie toutes les conditions et d√©bloque les nouveaux. Cr√©ez 2 achievements : \"first_coin\" (coins >= 1) et \"rich\" (coins >= 100). Testez avec coins:50. Affichez le nombre d√©bloqu√©s.",
      code_template: "// Classe AchievementSystem\n\n// Testez avec coins: 50\n",
      solution: 'class AchievementSystem {\n  constructor(achievements) {\n    this.achievements = achievements;\n    this.unlocked = [];\n  }\n  check(gameData) {\n    this.achievements.forEach(a => {\n      if (!this.unlocked.includes(a.id) && a.condition(gameData)) {\n        this.unlocked.push(a.id);\n      }\n    });\n    return this.unlocked;\n  }\n}\nlet as = new AchievementSystem([\n  { id: "first_coin", name: "Premi√®re pi√®ce", condition: (d) => d.coins >= 1 },\n  { id: "rich", name: "Riche", condition: (d) => d.coins >= 100 }\n]);\nas.check({ coins: 50 });\nconsole.log(as.unlocked.length);',
      tests: [{ type: "output", expected: "1" }],
      hint: "coins=50 : first_coin (>=1) ‚úì, rich (>=100) ‚úó ‚Üí 1 d√©bloqu√©.",
      help_steps: ["1. check parcourt les achievements et teste la condition", "2. 50 >= 1 ‚Üí true, 50 >= 100 ‚Üí false"],
    },
    {
      id: "js_s1_e90",
      title: "üéÆ Minimap",
      description: "Projet Mario #40 ‚Äî Mini-carte du niveau.",
      instruction: "Cr√©ez <code>Minimap</code> avec <code>scale</code> (ratio de r√©duction). <code>worldToMinimap(x, y)</code> retourne les coordonn√©es r√©duites. <code>render(player, enemies, coins)</code> retourne un r√©sum√©. Scale 0.1, joueur √† (500,300). Affichez la position minimap.",
      code_template: "// Classe Minimap\n\n// Testez\n",
      solution: "class Minimap {\n  constructor(scale) {\n    this.scale = scale;\n  }\n  worldToMinimap(x, y) {\n    return {\n      x: Math.round(x * this.scale),\n      y: Math.round(y * this.scale)\n    };\n  }\n  render(player, enemies, coins) {\n    let pos = this.worldToMinimap(player.x, player.y);\n    return `P(${pos.x},${pos.y}) E:${enemies.length} C:${coins.length}`;\n  }\n}\nlet mm = new Minimap(0.1);\nlet pos = mm.worldToMinimap(500, 300);\nconsole.log(`${pos.x},${pos.y}`);",
      tests: [{ type: "output", expected: "50,30" }],
      hint: "500 √ó 0.1 = 50, 300 √ó 0.1 = 30.",
      help_steps: ["1. worldToMinimap multiplie par scale"],
    },

    // === PROJET MARIO : FINAL (91-95) ===
    {
      id: "js_s1_e91",
      title: "üéÆ Transition de niveau",
      description: "Projet Mario #41 ‚Äî Animation de transition.",
      instruction: "Cr√©ez <code>Transition</code> avec <code>progress: 0, speed: 0.05, active: false, type</code>. <code>start(type)</code> active la transition. <code>update()</code> incr√©mente progress. <code>isComplete()</code> v√©rifie si progress >= 1. D√©marrez \"fadeOut\", faites 20 updates. Affichez isComplete().",
      code_template: "// Classe Transition\n\n// Testez fadeOut, 20 updates\n",
      solution: 'class Transition {\n  constructor() {\n    this.progress = 0;\n    this.speed = 0.05;\n    this.active = false;\n    this.type = "";\n  }\n  start(type) {\n    this.type = type;\n    this.active = true;\n    this.progress = 0;\n  }\n  update() {\n    if (this.active) {\n      this.progress += this.speed;\n      if (this.progress >= 1) this.progress = 1;\n    }\n  }\n  isComplete() {\n    return this.progress >= 1;\n  }\n}\nlet t = new Transition();\nt.start("fadeOut");\nfor (let i = 0; i < 20; i++) t.update();\nconsole.log(t.isComplete());',
      tests: [{ type: "output", expected: "true" }],
      hint: "20 √ó 0.05 = 1.0 ‚Üí complete.",
      help_steps: ["1. 20 updates √ó 0.05 = 1.0", "2. progress >= 1 ‚Üí true"],
    },
    {
      id: "js_s1_e92",
      title: "üéÆ Pool d'objets",
      description: "Projet Mario #42 ‚Äî Optimisation avec object pooling.",
      instruction: "Cr√©ez <code>ObjectPool</code> avec <code>pool</code> (tableau) et <code>active</code> (tableau). <code>get()</code> prend du pool ou cr√©e un nouvel objet. <code>release(obj)</code> remet dans le pool. Cr√©ez un pool, prenez 3 objets, rel√¢chez 1. Affichez la taille du pool.",
      code_template: "// Classe ObjectPool\n\n// Testez\n",
      solution: "class ObjectPool {\n  constructor(factory) {\n    this.pool = [];\n    this.active = [];\n    this.factory = factory;\n  }\n  get() {\n    let obj = this.pool.length > 0 ? this.pool.pop() : this.factory();\n    this.active.push(obj);\n    return obj;\n  }\n  release(obj) {\n    this.active = this.active.filter(o => o !== obj);\n    this.pool.push(obj);\n  }\n}\nlet pool = new ObjectPool(() => ({ x: 0, y: 0, active: true }));\nlet a = pool.get();\nlet b = pool.get();\nlet c = pool.get();\npool.release(b);\nconsole.log(pool.pool.length);",
      tests: [{ type: "output", expected: "1" }],
      hint: "3 pris, 1 rel√¢ch√© ‚Üí pool contient 1 objet.",
      help_steps: ["1. get() prend du pool ou cr√©e", "2. release() remet dans le pool"],
    },
    {
      id: "js_s1_e93",
      title: "üéÆ Leaderboard",
      description: "Projet Mario #43 ‚Äî Tableau des scores.",
      instruction: "Cr√©ez <code>Leaderboard</code> avec <code>scores</code> (tableau, max 5). <code>addScore(name, score)</code> ajoute, trie par score d√©croissant, garde les 5 meilleurs. <code>getTop(n)</code> retourne les n premiers. Ajoutez 3 scores, affichez le meilleur nom.",
      code_template: "// Classe Leaderboard\n\n// Ajoutez 3 scores, affichez le meilleur\n",
      solution: 'class Leaderboard {\n  constructor() {\n    this.scores = [];\n  }\n  addScore(name, score) {\n    this.scores.push({ name, score });\n    this.scores.sort((a, b) => b.score - a.score);\n    if (this.scores.length > 5) this.scores = this.scores.slice(0, 5);\n  }\n  getTop(n) {\n    return this.scores.slice(0, n);\n  }\n}\nlet lb = new Leaderboard();\nlb.addScore("Alice", 3000);\nlb.addScore("Bob", 5000);\nlb.addScore("Charlie", 1500);\nconsole.log(lb.getTop(1)[0].name);',
      tests: [{ type: "output", expected: "Bob" }],
      hint: "Triez par score d√©croissant. Bob (5000) est premier.",
      help_steps: ["1. sort((a,b) => b.score - a.score) pour trier d√©croissant", "2. Bob a le meilleur score"],
    },
    {
      id: "js_s1_e94",
      title: "üéÆ √âcran titre",
      description: "Projet Mario #44 ‚Äî Menu principal avec options.",
      instruction: "Cr√©ez <code>TitleScreen</code> avec <code>options</code> (tableau), <code>selectedIndex: 0</code>. <code>moveUp()</code> et <code>moveDown()</code> changent la s√©lection (avec boucle). <code>getSelected()</code> retourne l'option. 3 options, descendez 2 fois. Affichez la s√©lection.",
      code_template: "// Classe TitleScreen\n\n// 3 options, descendez 2 fois\n",
      solution: 'class TitleScreen {\n  constructor(options) {\n    this.options = options;\n    this.selectedIndex = 0;\n  }\n  moveUp() {\n    this.selectedIndex = (this.selectedIndex - 1 + this.options.length) % this.options.length;\n  }\n  moveDown() {\n    this.selectedIndex = (this.selectedIndex + 1) % this.options.length;\n  }\n  getSelected() {\n    return this.options[this.selectedIndex];\n  }\n}\nlet ts = new TitleScreen(["Nouvelle Partie", "Continuer", "Options"]);\nts.moveDown();\nts.moveDown();\nconsole.log(ts.getSelected());',
      tests: [{ type: "output", expected: "Options" }],
      hint: "Index 0 ‚Üí 1 ‚Üí 2 = Options.",
      help_steps: ["1. moveDown: (index + 1) % length", "2. 0 ‚Üí 1 ‚Üí 2 = 'Options'"],
    },
    {
      id: "js_s1_e95",
      title: "üéÆ Game Loop complet",
      description: "Projet Mario #45 ‚Äî La boucle de jeu principale.",
      instruction: "Cr√©ez <code>GameLoop</code> avec <code>frameCount: 0, running: false</code>. <code>start()</code>, <code>stop()</code>, <code>tick(updateFn)</code> qui appelle updateFn si running et incr√©mente frameCount. D√©marrez, faites 5 ticks (chaque tick ajoute 1 √† un compteur externe). Affichez le compteur.",
      code_template: "// Classe GameLoop\n\n// Testez avec 5 ticks\n",
      solution: "class GameLoop {\n  constructor() {\n    this.frameCount = 0;\n    this.running = false;\n  }\n  start() { this.running = true; }\n  stop() { this.running = false; }\n  tick(updateFn) {\n    if (this.running) {\n      updateFn();\n      this.frameCount++;\n    }\n  }\n}\nlet loop = new GameLoop();\nlet counter = 0;\nloop.start();\nfor (let i = 0; i < 5; i++) {\n  loop.tick(() => counter++);\n}\nconsole.log(counter);",
      tests: [{ type: "output", expected: "5" }],
      hint: "5 ticks, chacun incr√©mente counter ‚Üí 5.",
      help_steps: ["1. tick appelle updateFn si running", "2. 5 appels ‚Üí counter = 5"],
    },

    // === PROJET MARIO : ASSEMBLAGE FINAL (96-100) ===
    {
      id: "js_s1_e96",
      title: "üéÆ Collision multi-plateformes",
      description: "Projet Mario #46 ‚Äî G√©rez les collisions avec plusieurs plateformes.",
      instruction: "Cr√©ez <code>resolveCollisions(player, platforms)</code> qui teste chaque plateforme et place le joueur sur la premi√®re collision trouv√©e. Testez avec un joueur tombant (y:355, velY:5) et 2 plateformes. Affichez onGround.",
      code_template: "function resolveCollisions(player, platforms) {\n  player.onGround = false;\n  // Testez chaque plateforme\n}\n\nlet player = { x: 100, y: 355, width: 32, height: 32, velocityY: 5, onGround: false };\nlet platforms = [\n  { x: 0, y: 370, width: 800, height: 30 },\n  { x: 200, y: 250, width: 100, height: 20 }\n];\nresolveCollisions(player, platforms);\nconsole.log(player.onGround);\n",
      solution: "function resolveCollisions(player, platforms) {\n  player.onGround = false;\n  for (let p of platforms) {\n    if (player.x + player.width > p.x && player.x < p.x + p.width &&\n        player.y + player.height >= p.y && player.y + player.height <= p.y + p.height) {\n      player.y = p.y - player.height;\n      player.velocityY = 0;\n      player.onGround = true;\n      break;\n    }\n  }\n}\nlet player = { x: 100, y: 355, width: 32, height: 32, velocityY: 5, onGround: false };\nlet platforms = [\n  { x: 0, y: 370, width: 800, height: 30 },\n  { x: 200, y: 250, width: 100, height: 20 }\n];\nresolveCollisions(player, platforms);\nconsole.log(player.onGround);",
      tests: [{ type: "output", expected: "true" }],
      hint: "Le joueur (y:355+32=387) touche le sol (y:370). onGround = true.",
      help_steps: ["1. Boucle sur chaque plateforme", "2. V√©rifiez la collision AABB"],
    },
    {
      id: "js_s1_e97",
      title: "üéÆ Collecte de pi√®ces",
      description: "Projet Mario #47 ‚Äî Ramassez les pi√®ces du niveau.",
      instruction: "Cr√©ez <code>collectCoins(player, coins)</code> qui v√©rifie la collision avec chaque pi√®ce non collect√©e, la marque comme collect√©e et ajoute sa valeur au score. Testez avec 3 pi√®ces dont 1 √† port√©e. Affichez le score.",
      code_template: "function collectCoins(player, coins) {\n  // V√©rifiez et collectez\n}\n\nlet player = { x: 100, y: 300, width: 32, height: 32, score: 0 };\nlet coins = [\n  { x: 110, y: 310, size: 16, collected: false, value: 10 },\n  { x: 500, y: 200, size: 16, collected: false, value: 10 },\n  { x: 700, y: 100, size: 16, collected: false, value: 10 }\n];\ncollectCoins(player, coins);\nconsole.log(player.score);\n",
      solution: "function collectCoins(player, coins) {\n  for (let coin of coins) {\n    if (coin.collected) continue;\n    if (player.x < coin.x + coin.size && player.x + player.width > coin.x &&\n        player.y < coin.y + coin.size && player.y + player.height > coin.y) {\n      coin.collected = true;\n      player.score += coin.value;\n    }\n  }\n}\nlet player = { x: 100, y: 300, width: 32, height: 32, score: 0 };\nlet coins = [\n  { x: 110, y: 310, size: 16, collected: false, value: 10 },\n  { x: 500, y: 200, size: 16, collected: false, value: 10 },\n  { x: 700, y: 100, size: 16, collected: false, value: 10 }\n];\ncollectCoins(player, coins);\nconsole.log(player.score);",
      tests: [{ type: "output", expected: "10" }],
      hint: "Seule la pi√®ce √† (110,310) est √† port√©e du joueur (100,300). Score = 10.",
      help_steps: ["1. Collision AABB entre joueur et chaque pi√®ce", "2. Une seule pi√®ce est √† port√©e ‚Üí +10"],
    },
    {
      id: "js_s1_e98",
      title: "üéÆ Update complet du joueur",
      description: "Projet Mario #48 ‚Äî Boucle de mise √† jour du joueur.",
      instruction: "Cr√©ez <code>updatePlayer(player, input, gravity)</code> qui : applique le mouvement horizontal selon input, applique la gravit√©, met √† jour la position. Input: {left: false, right: true, jump: false}. Joueur √† (100,300) avec speed 5, gravity 0.5. Affichez x apr√®s update.",
      code_template: "function updatePlayer(player, input, gravity) {\n  // Mouvement, gravit√©, position\n}\n\nlet player = { x: 100, y: 300, width: 32, height: 32, velocityX: 0, velocityY: 0, speed: 5, jumpForce: -10, onGround: true };\nlet input = { left: false, right: true, jump: false };\nupdatePlayer(player, input, 0.5);\nconsole.log(player.x);\n",
      solution: "function updatePlayer(player, input, gravity) {\n  player.velocityX = 0;\n  if (input.left) player.velocityX = -player.speed;\n  if (input.right) player.velocityX = player.speed;\n  if (input.jump && player.onGround) {\n    player.velocityY = player.jumpForce;\n    player.onGround = false;\n  }\n  player.velocityY += gravity;\n  player.x += player.velocityX;\n  player.y += player.velocityY;\n}\nlet player = { x: 100, y: 300, width: 32, height: 32, velocityX: 0, velocityY: 0, speed: 5, jumpForce: -10, onGround: true };\nlet input = { left: false, right: true, jump: false };\nupdatePlayer(player, input, 0.5);\nconsole.log(player.x);",
      tests: [{ type: "output", expected: "105" }],
      hint: "right = true ‚Üí velocityX = 5. x = 100 + 5 = 105.",
      help_steps: ["1. input.right ‚Üí velocityX = speed = 5", "2. x += velocityX ‚Üí 100 + 5 = 105"],
    },
    {
      id: "js_s1_e99",
      title: "üéÆ Fin de niveau",
      description: "Projet Mario #49 ‚Äî D√©tection de fin de niveau.",
      instruction: "Cr√©ez <code>checkLevelComplete(player, flag, enemies)</code> : le niveau est termin√© si le joueur touche le drapeau ET tous les ennemis sont √©limin√©s (hp <= 0). Testez avec joueur sur le drapeau et 2 ennemis morts. Affichez <strong>\"Level Complete!\"</strong>.",
      code_template: "function checkLevelComplete(player, flag, enemies) {\n  // V√©rifiez les conditions\n}\n\nlet player = { x: 750, y: 300, width: 32, height: 32 };\nlet flag = { x: 760, y: 280, width: 20, height: 60 };\nlet enemies = [{ hp: 0 }, { hp: 0 }];\nif (checkLevelComplete(player, flag, enemies)) {\n  console.log(\"Level Complete!\");\n}\n",
      solution: 'function checkLevelComplete(player, flag, enemies) {\n  let touchFlag = player.x < flag.x + flag.width && player.x + player.width > flag.x &&\n    player.y < flag.y + flag.height && player.y + player.height > flag.y;\n  let allDead = enemies.every(e => e.hp <= 0);\n  return touchFlag && allDead;\n}\nlet player = { x: 750, y: 300, width: 32, height: 32 };\nlet flag = { x: 760, y: 280, width: 20, height: 60 };\nlet enemies = [{ hp: 0 }, { hp: 0 }];\nif (checkLevelComplete(player, flag, enemies)) {\n  console.log("Level Complete!");\n}',
      tests: [{ type: "output", expected: "Level Complete!" }],
      hint: "Collision joueur/drapeau + every() pour v√©rifier que tous les ennemis sont morts.",
      help_steps: ["1. Collision AABB joueur-drapeau", "2. enemies.every(e => e.hp <= 0)"],
    },
    {
      id: "js_s1_e100",
      title: "üéÆ üèÜ Assemblage Final !",
      description: "Projet Mario #50 ‚Äî Assemblez tous les syst√®mes !",
      instruction: "Cr√©ez un objet <code>Game</code> qui rassemble : player, platforms, coins, enemies, score, level. M√©thode <code>init()</code> qui initialise tout et <code>getStatus()</code> qui retourne un r√©sum√©. Initialisez et affichez le status.",
      code_template: "// L'objet Game final\n\n// Initialisez et affichez le status\n",
      solution: 'class Game {\n  constructor() {\n    this.player = null;\n    this.platforms = [];\n    this.coins = [];\n    this.enemies = [];\n    this.score = 0;\n    this.level = 1;\n    this.state = "menu";\n  }\n  init() {\n    this.player = { x: 50, y: 300, vies: 3 };\n    this.platforms = [\n      { x: 0, y: 370, width: 800, height: 30 },\n      { x: 200, y: 280, width: 100, height: 20 },\n      { x: 400, y: 200, width: 120, height: 20 }\n    ];\n    this.coins = [\n      { x: 230, y: 260, value: 10 },\n      { x: 440, y: 180, value: 10 }\n    ];\n    this.enemies = [\n      { x: 300, y: 338, hp: 30 },\n      { x: 600, y: 338, hp: 50 }\n    ];\n    this.state = "playing";\n    this.score = 0;\n  }\n  getStatus() {\n    return `Level:${this.level} Score:${this.score} Platforms:${this.platforms.length} Coins:${this.coins.length} Enemies:${this.enemies.length} State:${this.state}`;\n  }\n}\nlet game = new Game();\ngame.init();\nconsole.log(game.getStatus());',
      tests: [{ type: "output", expected: "Level:1 Score:0 Platforms:3 Coins:2 Enemies:2 State:playing" }],
      hint: "Rassemblez tout dans un objet Game avec init() et getStatus().",
      help_steps: ["1. init() cr√©e le joueur, plateformes, pi√®ces, ennemis", "2. getStatus() retourne un r√©sum√© format√©"],
    },
  ];

addExercises("javascript", exercises);
