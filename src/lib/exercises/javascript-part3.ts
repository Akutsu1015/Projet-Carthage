import { addExercises } from ".";
import type { Exercise } from "@/app/exercises/[module]/exercise-client";

// @ts-nocheck â€” Auto-converted from exercises-js-part3.js
const exercises: Exercise[] = [
    // === PROJET MARIO : FONDATIONS (51-55) ===
    {
      id: "js_s1_e51",
      title: "ðŸŽ® Config du jeu",
      description: "Projet Mario #1 â€” CrÃ©ez la configuration de base du jeu.",
      instruction: "CrÃ©ez un objet <code>GAME_CONFIG</code> avec : <code>width: 800</code>, <code>height: 400</code>, <code>gravity: 0.5</code>, <code>fps: 60</code>. Affichez <strong>\"Jeu: 800x400\"</strong>.",
      code_template: "// Configuration du jeu de plateforme\n\n// Affichez les dimensions\n",
      solution: 'const GAME_CONFIG = {\n  width: 800,\n  height: 400,\n  gravity: 0.5,\n  fps: 60\n};\nconsole.log(`Jeu: ${GAME_CONFIG.width}x${GAME_CONFIG.height}`);',
      tests: [{ type: "output", expected: "Jeu: 800x400" }],
      hint: "CrÃ©ez un objet const avec les propriÃ©tÃ©s demandÃ©es.",
      help_steps: ["1. <code>const GAME_CONFIG = { width: 800, height: 400, gravity: 0.5, fps: 60 };</code>"],
    },
    {
      id: "js_s1_e52",
      title: "ðŸŽ® Classe Joueur",
      description: "Projet Mario #2 â€” CrÃ©ez la classe du personnage joueur.",
      instruction: "CrÃ©ez une classe <code>Player</code> avec <code>x, y, width: 32, height: 32, velocityX: 0, velocityY: 0, speed: 5, jumpForce: -10, onGround: false, vies: 3, score: 0</code>. CrÃ©ez un joueur Ã  (100, 300) et affichez <strong>\"Player at 100,300\"</strong>.",
      code_template: "// Classe Player\n\n// CrÃ©ez un joueur et affichez sa position\n",
      solution: 'class Player {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.width = 32;\n    this.height = 32;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.speed = 5;\n    this.jumpForce = -10;\n    this.onGround = false;\n    this.vies = 3;\n    this.score = 0;\n  }\n}\nlet player = new Player(100, 300);\nconsole.log(`Player at ${player.x},${player.y}`);',
      tests: [{ type: "output", expected: "Player at 100,300" }],
      hint: "Utilisez un constructor avec tous les paramÃ¨tres par dÃ©faut.",
      help_steps: ["1. class Player { constructor(x, y) { this.x = x; ... } }"],
    },
    {
      id: "js_s1_e53",
      title: "ðŸŽ® Mouvement horizontal",
      description: "Projet Mario #3 â€” DÃ©placez le joueur Ã  gauche et Ã  droite.",
      instruction: "Ajoutez <code>moveLeft()</code> et <code>moveRight()</code> Ã  Player. moveLeft met velocityX Ã  <code>-speed</code>, moveRight Ã  <code>speed</code>. Ajoutez <code>update()</code> qui ajoute velocityX Ã  x. DÃ©placez Ã  droite, faites update, affichez la position x.",
      code_template: "class Player {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.speed = 5;\n    this.velocityX = 0;\n  }\n  // Ajoutez moveLeft, moveRight, update\n}\n\nlet p = new Player(100, 300);\n// DÃ©placez Ã  droite, update, affichez x\n",
      solution: 'class Player {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.speed = 5;\n    this.velocityX = 0;\n  }\n  moveLeft() { this.velocityX = -this.speed; }\n  moveRight() { this.velocityX = this.speed; }\n  update() { this.x += this.velocityX; }\n}\nlet p = new Player(100, 300);\np.moveRight();\np.update();\nconsole.log(p.x);',
      tests: [{ type: "output", expected: "105" }],
      hint: "moveRight() { this.velocityX = this.speed; } et update() { this.x += this.velocityX; }",
      help_steps: ["1. moveRight met velocityX = speed (5)", "2. update ajoute velocityX Ã  x : 100 + 5 = 105"],
    },
    {
      id: "js_s1_e54",
      title: "ðŸŽ® Saut du joueur",
      description: "Projet Mario #4 â€” ImplÃ©mentez le saut.",
      instruction: "Ajoutez <code>jump()</code> : si <code>onGround</code> est true, met velocityY Ã  <code>jumpForce</code> (-10) et onGround Ã  false. Ajoutez <code>applyGravity(gravity)</code> qui ajoute gravity Ã  velocityY et velocityY Ã  y. Testez : joueur au sol, saut, 1 frame de gravitÃ© (0.5). Affichez velocityY.",
      code_template: "class Player {\n  constructor(x, y) {\n    this.x = x; this.y = y;\n    this.velocityY = 0;\n    this.jumpForce = -10;\n    this.onGround = true;\n  }\n  // Ajoutez jump() et applyGravity(gravity)\n}\n\nlet p = new Player(100, 300);\np.jump();\np.applyGravity(0.5);\nconsole.log(p.velocityY);\n",
      solution: "class Player {\n  constructor(x, y) {\n    this.x = x; this.y = y;\n    this.velocityY = 0;\n    this.jumpForce = -10;\n    this.onGround = true;\n  }\n  jump() {\n    if (this.onGround) {\n      this.velocityY = this.jumpForce;\n      this.onGround = false;\n    }\n  }\n  applyGravity(gravity) {\n    this.velocityY += gravity;\n    this.y += this.velocityY;\n  }\n}\nlet p = new Player(100, 300);\np.jump();\np.applyGravity(0.5);\nconsole.log(p.velocityY);",
      tests: [{ type: "output", expected: "-9.5" }],
      hint: "AprÃ¨s jump: velocityY = -10. AprÃ¨s gravity(0.5): velocityY = -10 + 0.5 = -9.5",
      help_steps: ["1. jump() met velocityY Ã  jumpForce si onGround", "2. applyGravity ajoute gravity Ã  velocityY"],
    },
    {
      id: "js_s1_e55",
      title: "ðŸŽ® Classe Plateforme",
      description: "Projet Mario #5 â€” CrÃ©ez les plateformes.",
      instruction: "CrÃ©ez une classe <code>Platform</code> avec <code>x, y, width, height, type</code> (\"normal\" par dÃ©faut). CrÃ©ez le sol : <code>new Platform(0, 370, 800, 30)</code>. Affichez <strong>\"Sol: 0,370 800x30\"</strong>.",
      code_template: "// Classe Platform\n\n// CrÃ©ez le sol et affichez\n",
      solution: 'class Platform {\n  constructor(x, y, width, height, type = "normal") {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.type = type;\n  }\n}\nlet sol = new Platform(0, 370, 800, 30);\nconsole.log(`Sol: ${sol.x},${sol.y} ${sol.width}x${sol.height}`);',
      tests: [{ type: "output", expected: "Sol: 0,370 800x30" }],
      hint: "class Platform { constructor(x, y, width, height, type = \"normal\") { ... } }",
      help_steps: ["1. CrÃ©ez la classe avec les propriÃ©tÃ©s", "2. new Platform(0, 370, 800, 30)"],
    },

    // === PROJET MARIO : COLLISIONS (56-60) ===
    {
      id: "js_s1_e56",
      title: "ðŸŽ® DÃ©tection de collision",
      description: "Projet Mario #6 â€” AABB collision detection.",
      instruction: "CrÃ©ez une fonction <code>checkCollision(a, b)</code> qui vÃ©rifie si deux rectangles se chevauchent (AABB). Chaque objet a x, y, width, height. Testez avec deux objets qui se touchent. Affichez <strong>true</strong>.",
      code_template: "// Fonction de collision AABB\n\n// Testez\nlet a = { x: 10, y: 10, width: 50, height: 50 };\nlet b = { x: 40, y: 40, width: 50, height: 50 };\nconsole.log(checkCollision(a, b));\n",
      solution: "function checkCollision(a, b) {\n  return a.x < b.x + b.width &&\n    a.x + a.width > b.x &&\n    a.y < b.y + b.height &&\n    a.y + a.height > b.y;\n}\nlet a = { x: 10, y: 10, width: 50, height: 50 };\nlet b = { x: 40, y: 40, width: 50, height: 50 };\nconsole.log(checkCollision(a, b));",
      tests: [{ type: "output", expected: "true" }],
      hint: "AABB: les 4 conditions de non-chevauchement inversÃ©es.",
      help_steps: ["1. a.x < b.x + b.width (a pas trop Ã  droite)", "2. a.x + a.width > b.x (a pas trop Ã  gauche)", "3. MÃªme logique pour y"],
    },
    {
      id: "js_s1_e57",
      title: "ðŸŽ® Collision avec le sol",
      description: "Projet Mario #7 â€” EmpÃªchez le joueur de tomber.",
      instruction: "CrÃ©ez <code>checkGroundCollision(player, platform)</code> : si le bas du joueur dÃ©passe le haut de la plateforme et qu'il y a chevauchement horizontal, replacez-le sur la plateforme et mettez onGround Ã  true. Testez et affichez <strong>\"onGround: true\"</strong>.",
      code_template: "function checkGroundCollision(player, platform) {\n  // Si le joueur tombe sur la plateforme\n}\n\nlet player = { x: 50, y: 360, width: 32, height: 32, velocityY: 5, onGround: false };\nlet sol = { x: 0, y: 370, width: 800, height: 30 };\ncheckGroundCollision(player, sol);\nconsole.log(`onGround: ${player.onGround}`);\n",
      solution: "function checkGroundCollision(player, platform) {\n  if (player.y + player.height >= platform.y &&\n      player.y + player.height <= platform.y + platform.height &&\n      player.x + player.width > platform.x &&\n      player.x < platform.x + platform.width) {\n    player.y = platform.y - player.height;\n    player.velocityY = 0;\n    player.onGround = true;\n  }\n}\nlet player = { x: 50, y: 360, width: 32, height: 32, velocityY: 5, onGround: false };\nlet sol = { x: 0, y: 370, width: 800, height: 30 };\ncheckGroundCollision(player, sol);\nconsole.log(`onGround: ${player.onGround}`);",
      tests: [{ type: "output", expected: "onGround: true" }],
      hint: "VÃ©rifiez si le bas du joueur (y + height) atteint le haut de la plateforme (platform.y).",
      help_steps: ["1. Condition: player.y + player.height >= platform.y", "2. Replacer: player.y = platform.y - player.height"],
    },
    {
      id: "js_s1_e58",
      title: "ðŸŽ® Limites de l'Ã©cran",
      description: "Projet Mario #8 â€” Gardez le joueur dans l'Ã©cran.",
      instruction: "CrÃ©ez <code>clampToScreen(player, screenW, screenH)</code> qui empÃªche le joueur de sortir. Testez avec un joueur Ã  x=-10. Affichez sa position x corrigÃ©e (<strong>0</strong>).",
      code_template: "function clampToScreen(player, screenW, screenH) {\n  // EmpÃªchez le joueur de sortir\n}\n\nlet player = { x: -10, y: 200, width: 32, height: 32 };\nclampToScreen(player, 800, 400);\nconsole.log(player.x);\n",
      solution: "function clampToScreen(player, screenW, screenH) {\n  if (player.x < 0) player.x = 0;\n  if (player.x + player.width > screenW) player.x = screenW - player.width;\n  if (player.y < 0) player.y = 0;\n  if (player.y + player.height > screenH) player.y = screenH - player.height;\n}\nlet player = { x: -10, y: 200, width: 32, height: 32 };\nclampToScreen(player, 800, 400);\nconsole.log(player.x);",
      tests: [{ type: "output", expected: "0" }],
      hint: "Si x < 0, mettre x = 0. Si x + width > screenW, mettre x = screenW - width.",
      help_steps: ["1. VÃ©rifiez les 4 bords", "2. x < 0 â†’ x = 0"],
    },
    {
      id: "js_s1_e59",
      title: "ðŸŽ® Classe PiÃ¨ce",
      description: "Projet Mario #9 â€” CrÃ©ez les piÃ¨ces Ã  collecter.",
      instruction: "CrÃ©ez une classe <code>Coin</code> avec <code>x, y, size: 16, collected: false, value: 10</code>. Ajoutez <code>collect()</code> qui met collected Ã  true et retourne value. CrÃ©ez une piÃ¨ce, collectez-la, affichez la valeur.",
      code_template: "// Classe Coin\n\n// CrÃ©ez, collectez, affichez\n",
      solution: "class Coin {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.size = 16;\n    this.collected = false;\n    this.value = 10;\n  }\n  collect() {\n    this.collected = true;\n    return this.value;\n  }\n}\nlet coin = new Coin(200, 300);\nlet points = coin.collect();\nconsole.log(points);",
      tests: [{ type: "output", expected: "10" }],
      hint: "collect() { this.collected = true; return this.value; }",
      help_steps: ["1. Classe avec constructor et mÃ©thode collect()", "2. collect retourne la valeur de la piÃ¨ce"],
    },
    {
      id: "js_s1_e60",
      title: "ðŸŽ® Classe Ennemi",
      description: "Projet Mario #10 â€” CrÃ©ez les ennemis avec patrouille.",
      instruction: "CrÃ©ez <code>Enemy</code> avec <code>x, y, width: 32, height: 32, speed: 2, direction: 1, minX, maxX</code>. Ajoutez <code>patrol()</code> : dÃ©place l'ennemi et inverse la direction aux limites. Faites 3 patrouilles depuis x=100 (min:50, max:150). Affichez x.",
      code_template: "// Classe Enemy avec patrouille\n\n// CrÃ©ez un ennemi et faites 3 patrouilles\n",
      solution: "class Enemy {\n  constructor(x, y, minX, maxX) {\n    this.x = x;\n    this.y = y;\n    this.width = 32;\n    this.height = 32;\n    this.speed = 2;\n    this.direction = 1;\n    this.minX = minX;\n    this.maxX = maxX;\n  }\n  patrol() {\n    this.x += this.speed * this.direction;\n    if (this.x >= this.maxX || this.x <= this.minX) {\n      this.direction *= -1;\n    }\n  }\n}\nlet goomba = new Enemy(100, 338, 50, 150);\ngoomba.patrol();\ngoomba.patrol();\ngoomba.patrol();\nconsole.log(goomba.x);",
      tests: [{ type: "output", expected: "106" }],
      hint: "patrol: x += speed * direction. Si hors limites, direction *= -1.",
      help_steps: ["1. patrol() dÃ©place et vÃ©rifie les limites", "2. 100 â†’ 102 â†’ 104 â†’ 106"],
    },

    // === PROJET MARIO : GAMEPLAY (61-65) ===
    {
      id: "js_s1_e61",
      title: "ðŸŽ® SystÃ¨me de vies",
      description: "Projet Mario #11 â€” GÃ©rez les vies du joueur.",
      instruction: "CrÃ©ez <code>LifeSystem</code> avec <code>lives: 3, maxLives: 5</code>. MÃ©thodes : <code>loseLife()</code> (retourne false si game over), <code>gainLife()</code> (max 5), <code>isGameOver()</code>. Perdez 2 vies, affichez les vies restantes.",
      code_template: "// Classe LifeSystem\n\n// Testez\n",
      solution: 'class LifeSystem {\n  constructor() {\n    this.lives = 3;\n    this.maxLives = 5;\n  }\n  loseLife() {\n    this.lives--;\n    return this.lives > 0;\n  }\n  gainLife() {\n    if (this.lives < this.maxLives) this.lives++;\n  }\n  isGameOver() {\n    return this.lives <= 0;\n  }\n}\nlet ls = new LifeSystem();\nls.loseLife();\nls.loseLife();\nconsole.log(ls.lives);',
      tests: [{ type: "output", expected: "1" }],
      hint: "loseLife() dÃ©crÃ©mente et vÃ©rifie si > 0.",
      help_steps: ["1. loseLife() { this.lives--; return this.lives > 0; }", "2. 3 - 2 = 1"],
    },
    {
      id: "js_s1_e62",
      title: "ðŸŽ® SystÃ¨me de score",
      description: "Projet Mario #12 â€” Score avec multiplicateur.",
      instruction: "CrÃ©ez <code>ScoreSystem</code> avec <code>score: 0, multiplier: 1, combo: 0</code>. <code>addPoints(pts)</code> ajoute pts Ã— multiplier. <code>addCombo()</code> incrÃ©mente combo et met multiplier Ã  <code>1 + combo * 0.5</code>. Faites 3 combos puis ajoutez 100 points. Affichez le score.",
      code_template: "// Classe ScoreSystem\n\n// 3 combos puis 100 points\n",
      solution: "class ScoreSystem {\n  constructor() {\n    this.score = 0;\n    this.multiplier = 1;\n    this.combo = 0;\n  }\n  addPoints(pts) {\n    this.score += pts * this.multiplier;\n  }\n  addCombo() {\n    this.combo++;\n    this.multiplier = 1 + this.combo * 0.5;\n  }\n}\nlet ss = new ScoreSystem();\nss.addCombo();\nss.addCombo();\nss.addCombo();\nss.addPoints(100);\nconsole.log(ss.score);",
      tests: [{ type: "output", expected: "250" }],
      hint: "3 combos â†’ multiplier = 1 + 3*0.5 = 2.5. Score = 100 * 2.5 = 250.",
      help_steps: ["1. AprÃ¨s 3 combos: multiplier = 2.5", "2. 100 * 2.5 = 250"],
    },
    {
      id: "js_s1_e63",
      title: "ðŸŽ® Power-ups",
      description: "Projet Mario #13 â€” SystÃ¨me de power-ups.",
      instruction: "CrÃ©ez <code>PowerUp</code> avec <code>type</code> (\"star\", \"mushroom\", \"flower\"), <code>duration</code> (en frames), <code>active: false</code>. MÃ©thode <code>activate(player)</code> : si star â†’ player.invincible = true; si mushroom â†’ player.big = true; si flower â†’ player.canShoot = true. Activez un star sur un joueur, affichez <strong>\"Invincible: true\"</strong>.",
      code_template: "class PowerUp {\n  constructor(type, duration) {\n    this.type = type;\n    this.duration = duration;\n    this.active = false;\n  }\n  // Ajoutez activate(player)\n}\n\nlet player = { invincible: false, big: false, canShoot: false };\nlet star = new PowerUp(\"star\", 300);\nstar.activate(player);\nconsole.log(`Invincible: ${player.invincible}`);\n",
      solution: 'class PowerUp {\n  constructor(type, duration) {\n    this.type = type;\n    this.duration = duration;\n    this.active = false;\n  }\n  activate(player) {\n    this.active = true;\n    if (this.type === "star") player.invincible = true;\n    if (this.type === "mushroom") player.big = true;\n    if (this.type === "flower") player.canShoot = true;\n  }\n}\nlet player = { invincible: false, big: false, canShoot: false };\nlet star = new PowerUp("star", 300);\nstar.activate(player);\nconsole.log(`Invincible: ${player.invincible}`);',
      tests: [{ type: "output", expected: "Invincible: true" }],
      hint: "activate vÃ©rifie le type et modifie la propriÃ©tÃ© correspondante du joueur.",
      help_steps: ["1. if (this.type === \"star\") player.invincible = true;"],
    },
    {
      id: "js_s1_e64",
      title: "ðŸŽ® GÃ©nÃ©rateur de niveau",
      description: "Projet Mario #14 â€” GÃ©nÃ©rez un niveau avec des plateformes.",
      instruction: "CrÃ©ez <code>generateLevel(numPlatforms)</code> qui retourne un tableau de plateformes. Chaque plateforme a x alÃ©atoire (0-700), y alÃ©atoire (100-350), width entre 60 et 150. GÃ©nÃ©rez 5 plateformes et affichez le nombre.",
      code_template: "function generateLevel(numPlatforms) {\n  // GÃ©nÃ©rez les plateformes\n}\n\nlet level = generateLevel(5);\nconsole.log(level.length);\n",
      solution: "function generateLevel(numPlatforms) {\n  let platforms = [];\n  for (let i = 0; i < numPlatforms; i++) {\n    platforms.push({\n      x: Math.floor(Math.random() * 700),\n      y: 100 + Math.floor(Math.random() * 250),\n      width: 60 + Math.floor(Math.random() * 90),\n      height: 20\n    });\n  }\n  return platforms;\n}\nlet level = generateLevel(5);\nconsole.log(level.length);",
      tests: [{ type: "output", expected: "5" }],
      hint: "Math.random() * range pour des valeurs alÃ©atoires, push dans un tableau.",
      help_steps: ["1. Boucle for de 0 Ã  numPlatforms", "2. push un objet avec x, y, width alÃ©atoires"],
    },
    {
      id: "js_s1_e65",
      title: "ðŸŽ® SystÃ¨me d'animation",
      description: "Projet Mario #15 â€” Sprite animation basique.",
      instruction: "CrÃ©ez <code>Animation</code> avec <code>frames</code> (tableau), <code>frameIndex: 0</code>, <code>frameDelay</code>, <code>counter: 0</code>. <code>update()</code> incrÃ©mente counter, et quand counter >= frameDelay, passe au frame suivant (boucle). CrÃ©ez une animation de 4 frames (delay 5), faites 11 updates. Affichez le frameIndex.",
      code_template: "// Classe Animation\n\n// Testez avec 4 frames, delay 5, 11 updates\n",
      solution: 'class Animation {\n  constructor(frames, frameDelay) {\n    this.frames = frames;\n    this.frameIndex = 0;\n    this.frameDelay = frameDelay;\n    this.counter = 0;\n  }\n  update() {\n    this.counter++;\n    if (this.counter >= this.frameDelay) {\n      this.counter = 0;\n      this.frameIndex = (this.frameIndex + 1) % this.frames.length;\n    }\n  }\n  getCurrentFrame() {\n    return this.frames[this.frameIndex];\n  }\n}\nlet anim = new Animation(["idle1", "idle2", "idle3", "idle4"], 5);\nfor (let i = 0; i < 11; i++) anim.update();\nconsole.log(anim.frameIndex);',
      tests: [{ type: "output", expected: "2" }],
      hint: "11 updates avec delay 5 : frame change Ã  5 (â†’1) et 10 (â†’2). frameIndex = 2.",
      help_steps: ["1. counter++ Ã  chaque update", "2. Quand counter >= delay: reset counter, frameIndex = (frameIndex+1) % length"],
    },

    // === PROJET MARIO : AVANCÃ‰ (66-70) ===
    {
      id: "js_s1_e66",
      title: "ðŸŽ® Gestion des touches",
      description: "Projet Mario #16 â€” Input handler.",
      instruction: "CrÃ©ez <code>InputHandler</code> avec un objet <code>keys</code> (toutes les touches Ã  false). MÃ©thodes <code>keyDown(key)</code> et <code>keyUp(key)</code>. <code>isPressed(key)</code> retourne l'Ã©tat. Appuyez sur \"ArrowRight\" et vÃ©rifiez. Affichez <strong>true</strong>.",
      code_template: "// Classe InputHandler\n\n// Testez\n",
      solution: 'class InputHandler {\n  constructor() {\n    this.keys = {};\n  }\n  keyDown(key) {\n    this.keys[key] = true;\n  }\n  keyUp(key) {\n    this.keys[key] = false;\n  }\n  isPressed(key) {\n    return this.keys[key] === true;\n  }\n}\nlet input = new InputHandler();\ninput.keyDown("ArrowRight");\nconsole.log(input.isPressed("ArrowRight"));',
      tests: [{ type: "output", expected: "true" }],
      hint: "Utilisez un objet pour stocker l'Ã©tat de chaque touche.",
      help_steps: ["1. keys = {} puis keys[key] = true/false"],
    },
    {
      id: "js_s1_e67",
      title: "ðŸŽ® CamÃ©ra scrolling",
      description: "Projet Mario #17 â€” CamÃ©ra qui suit le joueur.",
      instruction: "CrÃ©ez <code>Camera</code> avec <code>x: 0, y: 0, width, height</code>. MÃ©thode <code>follow(target)</code> qui centre la camÃ©ra sur target. <code>x = target.x - width/2</code>. Suivez un joueur Ã  x=500 avec une camÃ©ra 800Ã—400. Affichez camera.x.",
      code_template: "// Classe Camera\n\n// Testez\n",
      solution: "class Camera {\n  constructor(width, height) {\n    this.x = 0;\n    this.y = 0;\n    this.width = width;\n    this.height = height;\n  }\n  follow(target) {\n    this.x = target.x - this.width / 2;\n    this.y = target.y - this.height / 2;\n  }\n}\nlet cam = new Camera(800, 400);\ncam.follow({ x: 500, y: 300 });\nconsole.log(cam.x);",
      tests: [{ type: "output", expected: "100" }],
      hint: "camera.x = target.x - width/2 = 500 - 400 = 100.",
      help_steps: ["1. follow centre la camÃ©ra sur le joueur", "2. 500 - 800/2 = 100"],
    },
    {
      id: "js_s1_e68",
      title: "ðŸŽ® Particules",
      description: "Projet Mario #18 â€” SystÃ¨me de particules.",
      instruction: "CrÃ©ez <code>ParticleSystem</code> avec un tableau <code>particles</code>. <code>emit(x, y, count)</code> crÃ©e count particules avec position, velocitÃ© alÃ©atoire et lifetime de 30. <code>update()</code> dÃ©place et rÃ©duit lifetime, supprime les mortes. Ã‰mettez 10 particules, faites 1 update. Affichez le nombre restant.",
      code_template: "// Classe ParticleSystem\n\n// Ã‰mettez 10, update 1 fois, affichez le count\n",
      solution: "class ParticleSystem {\n  constructor() {\n    this.particles = [];\n  }\n  emit(x, y, count) {\n    for (let i = 0; i < count; i++) {\n      this.particles.push({\n        x: x,\n        y: y,\n        vx: (Math.random() - 0.5) * 4,\n        vy: (Math.random() - 0.5) * 4,\n        lifetime: 30\n      });\n    }\n  }\n  update() {\n    this.particles.forEach(p => {\n      p.x += p.vx;\n      p.y += p.vy;\n      p.lifetime--;\n    });\n    this.particles = this.particles.filter(p => p.lifetime > 0);\n  }\n}\nlet ps = new ParticleSystem();\nps.emit(100, 100, 10);\nps.update();\nconsole.log(ps.particles.length);",
      tests: [{ type: "output", expected: "10" }],
      hint: "AprÃ¨s 1 update, lifetime = 29 (> 0), donc toutes les 10 survivent.",
      help_steps: ["1. emit crÃ©e des particules avec lifetime 30", "2. update: lifetime-- puis filter(p => p.lifetime > 0)"],
    },
    {
      id: "js_s1_e69",
      title: "ðŸŽ® Tilemap",
      description: "Projet Mario #19 â€” Carte en tuiles.",
      instruction: "CrÃ©ez <code>TileMap</code> avec une grille 2D et <code>tileSize</code>. <code>getTile(col, row)</code> retourne la valeur. <code>worldToTile(x, y)</code> convertit les coordonnÃ©es monde en indices. CrÃ©ez une map 3Ã—3 avec tileSize 32. VÃ©rifiez quelle tuile est Ã  la position (50, 50). Affichez la valeur.",
      code_template: "// Classe TileMap\n\nlet map = [\n  [1, 1, 1],\n  [0, 0, 0],\n  [1, 1, 1]\n];\n// CrÃ©ez un TileMap et trouvez la tuile Ã  (50, 50)\n",
      solution: "class TileMap {\n  constructor(grid, tileSize) {\n    this.grid = grid;\n    this.tileSize = tileSize;\n  }\n  getTile(col, row) {\n    if (row >= 0 && row < this.grid.length && col >= 0 && col < this.grid[0].length) {\n      return this.grid[row][col];\n    }\n    return -1;\n  }\n  worldToTile(x, y) {\n    return {\n      col: Math.floor(x / this.tileSize),\n      row: Math.floor(y / this.tileSize)\n    };\n  }\n}\nlet map = [\n  [1, 1, 1],\n  [0, 0, 0],\n  [1, 1, 1]\n];\nlet tm = new TileMap(map, 32);\nlet pos = tm.worldToTile(50, 50);\nconsole.log(tm.getTile(pos.col, pos.row));",
      tests: [{ type: "output", expected: "0" }],
      hint: "50/32 = 1.56 â†’ floor = 1. grid[1][1] = 0.",
      help_steps: ["1. worldToTile: Math.floor(x / tileSize)", "2. 50/32 â†’ col=1, row=1 â†’ grid[1][1] = 0"],
    },
    {
      id: "js_s1_e70",
      title: "ðŸŽ® Sauvegarde du jeu",
      description: "Projet Mario #20 â€” Save/Load avec localStorage.",
      instruction: "CrÃ©ez <code>SaveManager</code> avec <code>save(data)</code> qui sÃ©rialise en JSON dans localStorage, et <code>load()</code> qui dÃ©sÃ©rialise. Sauvegardez <code>{ level: 3, score: 2500 }</code>, rechargez et affichez le score.",
      code_template: "// Classe SaveManager\n\n// Sauvegardez et rechargez\n",
      solution: 'class SaveManager {\n  constructor(key) {\n    this.key = key;\n  }\n  save(data) {\n    localStorage.setItem(this.key, JSON.stringify(data));\n  }\n  load() {\n    const raw = localStorage.getItem(this.key);\n    return raw ? JSON.parse(raw) : null;\n  }\n}\nlet sm = new SaveManager("mario_save");\nsm.save({ level: 3, score: 2500 });\nlet data = sm.load();\nconsole.log(data.score);',
      tests: [{ type: "output", expected: "2500" }],
      hint: "JSON.stringify pour sauvegarder, JSON.parse pour charger.",
      help_steps: ["1. save: localStorage.setItem(key, JSON.stringify(data))", "2. load: JSON.parse(localStorage.getItem(key))"],
    },

    // === PROJET MARIO : POLISH (71-75) ===
    {
      id: "js_s1_e71",
      title: "ðŸŽ® Timer de jeu",
      description: "Projet Mario #21 â€” ChronomÃ¨tre de niveau.",
      instruction: "CrÃ©ez <code>GameTimer</code> avec <code>timeLeft</code> (en secondes), <code>running: false</code>. <code>start()</code>, <code>tick()</code> (dÃ©crÃ©mente si running), <code>isTimeUp()</code>. CrÃ©ez un timer de 100s, dÃ©marrez, faites 3 ticks. Affichez le temps restant.",
      code_template: "// Classe GameTimer\n\n// Testez\n",
      solution: "class GameTimer {\n  constructor(seconds) {\n    this.timeLeft = seconds;\n    this.running = false;\n  }\n  start() { this.running = true; }\n  tick() {\n    if (this.running && this.timeLeft > 0) this.timeLeft--;\n  }\n  isTimeUp() { return this.timeLeft <= 0; }\n}\nlet timer = new GameTimer(100);\ntimer.start();\ntimer.tick();\ntimer.tick();\ntimer.tick();\nconsole.log(timer.timeLeft);",
      tests: [{ type: "output", expected: "97" }],
      hint: "100 - 3 ticks = 97.",
      help_steps: ["1. tick() dÃ©crÃ©mente si running et timeLeft > 0"],
    },
    {
      id: "js_s1_e72",
      title: "ðŸŽ® Ã‰cran de Game Over",
      description: "Projet Mario #22 â€” Ã‰tats du jeu.",
      instruction: "CrÃ©ez <code>GameState</code> avec <code>state: \"menu\"</code>. MÃ©thodes : <code>startGame()</code> â†’ \"playing\", <code>pauseGame()</code> â†’ \"paused\", <code>gameOver()</code> â†’ \"gameover\", <code>backToMenu()</code> â†’ \"menu\". EnchaÃ®nez : start, pause, start, gameOver. Affichez l'Ã©tat.",
      code_template: "// Classe GameState\n\n// Testez la sÃ©quence\n",
      solution: 'class GameState {\n  constructor() {\n    this.state = "menu";\n  }\n  startGame() { this.state = "playing"; }\n  pauseGame() { this.state = "paused"; }\n  gameOver() { this.state = "gameover"; }\n  backToMenu() { this.state = "menu"; }\n  getState() { return this.state; }\n}\nlet gs = new GameState();\ngs.startGame();\ngs.pauseGame();\ngs.startGame();\ngs.gameOver();\nconsole.log(gs.getState());',
      tests: [{ type: "output", expected: "gameover" }],
      hint: "Chaque mÃ©thode change simplement this.state.",
      help_steps: ["1. SÃ©quence: menu â†’ playing â†’ paused â†’ playing â†’ gameover"],
    },
    {
      id: "js_s1_e73",
      title: "ðŸŽ® Effets sonores",
      description: "Projet Mario #23 â€” Gestionnaire de sons.",
      instruction: "CrÃ©ez <code>SoundManager</code> avec un objet <code>sounds</code> et <code>muted: false</code>. <code>register(name, url)</code> enregistre un son. <code>play(name)</code> affiche \"Playing: name\" si non mutÃ©. <code>toggleMute()</code> inverse muted. Enregistrez \"jump\", jouez-le, mutez, rejouez. Comptez les messages affichÃ©s.",
      code_template: "// Classe SoundManager\n\n// Testez\n",
      solution: 'class SoundManager {\n  constructor() {\n    this.sounds = {};\n    this.muted = false;\n  }\n  register(name, url) {\n    this.sounds[name] = url;\n  }\n  play(name) {\n    if (!this.muted && this.sounds[name]) {\n      console.log("Playing: " + name);\n    }\n  }\n  toggleMute() {\n    this.muted = !this.muted;\n  }\n}\nlet sm = new SoundManager();\nsm.register("jump", "jump.mp3");\nsm.play("jump");\nsm.toggleMute();\nsm.play("jump");\nconsole.log("Done");',
      tests: [
        { type: "output", expected: "Playing: jump" },
        { type: "output", expected: "Done" },
      ],
      hint: "Le 2Ã¨me play ne s'affiche pas car mutÃ©.",
      help_steps: ["1. play vÃ©rifie !this.muted avant d'afficher"],
    },
    {
      id: "js_s1_e74",
      title: "ðŸŽ® SystÃ¨me de checkpoints",
      description: "Projet Mario #24 â€” Points de sauvegarde.",
      instruction: "CrÃ©ez <code>CheckpointSystem</code> avec un tableau <code>checkpoints</code> et <code>lastCheckpoint: null</code>. <code>addCheckpoint(x, y)</code> ajoute un point. <code>activate(index)</code> sauvegarde la position. <code>respawn(player)</code> remet le joueur au dernier checkpoint. Ajoutez 2 checkpoints, activez le 2Ã¨me, respawnez. Affichez player.x.",
      code_template: "// Classe CheckpointSystem\n\n// Testez\n",
      solution: "class CheckpointSystem {\n  constructor() {\n    this.checkpoints = [];\n    this.lastCheckpoint = null;\n  }\n  addCheckpoint(x, y) {\n    this.checkpoints.push({ x, y });\n  }\n  activate(index) {\n    this.lastCheckpoint = this.checkpoints[index];\n  }\n  respawn(player) {\n    if (this.lastCheckpoint) {\n      player.x = this.lastCheckpoint.x;\n      player.y = this.lastCheckpoint.y;\n    }\n  }\n}\nlet cs = new CheckpointSystem();\ncs.addCheckpoint(100, 300);\ncs.addCheckpoint(500, 250);\ncs.activate(1);\nlet player = { x: 0, y: 0 };\ncs.respawn(player);\nconsole.log(player.x);",
      tests: [{ type: "output", expected: "500" }],
      hint: "activate sauvegarde le checkpoint, respawn remet le joueur Ã  cette position.",
      help_steps: ["1. activate(1) â†’ lastCheckpoint = {x:500, y:250}", "2. respawn met player.x = 500"],
    },
    {
      id: "js_s1_e75",
      title: "ðŸŽ® Inventaire",
      description: "Projet Mario #25 â€” SystÃ¨me d'inventaire.",
      instruction: "CrÃ©ez <code>Inventory</code> avec <code>items</code> (tableau), <code>maxSize: 5</code>. <code>addItem(item)</code> ajoute si pas plein (retourne true/false). <code>removeItem(name)</code> retire par nom. <code>hasItem(name)</code> vÃ©rifie. Ajoutez \"clÃ©\", \"champignon\", vÃ©rifiez \"clÃ©\". Affichez <strong>true</strong>.",
      code_template: "// Classe Inventory\n\n// Testez\n",
      solution: 'class Inventory {\n  constructor(maxSize = 5) {\n    this.items = [];\n    this.maxSize = maxSize;\n  }\n  addItem(item) {\n    if (this.items.length >= this.maxSize) return false;\n    this.items.push(item);\n    return true;\n  }\n  removeItem(name) {\n    this.items = this.items.filter(i => i !== name);\n  }\n  hasItem(name) {\n    return this.items.includes(name);\n  }\n}\nlet inv = new Inventory();\ninv.addItem("clÃ©");\ninv.addItem("champignon");\nconsole.log(inv.hasItem("clÃ©"));',
      tests: [{ type: "output", expected: "true" }],
      hint: "addItem vÃ©rifie la taille max, hasItem utilise includes().",
      help_steps: ["1. addItem push si length < maxSize", "2. hasItem: this.items.includes(name)"],
    },
  ];

addExercises("javascript", exercises);
